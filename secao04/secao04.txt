Seção 4: Desenvolvimento de aplicações Web Intermediário


21. O que vamos aprender nesta seção?


22. Controller tipados. Como construir um controller para um model.

Model
Quando desenvolvemos com ASP.Net MVC temos três elementos básicos, a Model, a View e o Controller.
Já vimos o que a camada Model pode fazer. Agora vamos ver como podemos passar informação para a View usando um Model ou melhor, um Viewmodel.



Quando trabalhamos com Views, podemos passar informação desde a Controller para a View para poder exibir essas informações.
Imagina ter um cadastro de clientes por exemplo. Um usuário poderia querer exibir o Id e o Nome de um cliente no navegador.


Como fazer no ASP.Net?

Primeiro modifica a Controller desta forma:
public ActionResult Details(int id) {
	var Cliente = ClasseDaCamadaModelCliente.BuscarPorID(id);
	return View(Cliente);
}


Para exibir isso na View:


@model MVC_.net_core.Models.Cliente
<div>
<h4>Cliente</h4>
<hr />
<dl class="row">
<dt class = "col-sm-2">
@Html.DisplayNameFor(model => model.id)
</dt>
<dd class = "col-sm-10">
@Html.DisplayFor(model => model.id)
</dd>
<dt class = "col-sm-2">
@Html.DisplayNameFor(model => model.nome)
</dt>
<dd class = "col-sm-10">
@Html.DisplayFor(model => model.nome)
</dd>
</dl>
</div>


Notem que há duas coisas importantes aqui, fazer o “import” do Model na View.

@model MVC_.net_core.Models.Cliente

E usar HTML Helpers para acessar e mostrar as propriedades da classe Cliente.

@Html.DisplayNameFor(model => model.id)
@Html.DisplayFor(model => model.id)

Lambdas são usadas no parametro do método helper




23. Extensibilidade de controllers.


ASP.Net Controllers

Um controller é uma classe. Como toda classe podemos criar extensões.

Ou seja, podemos criar nossos próprios Controllers com funções específicas.

Desta forma podemos reutilizar código usado numa controller.


Um exemplo disto é o envio de mensagens de informação, erro ou sucesso.

Com certeza esse tipo de mensagem será usada em toda parte no sistema.

Em lugar de repetir esse código, podemos criar um Controller do qual os outros Controllers do sistema possam herdar.

Lembram de herança?


Como se faz isto?
Podemos criar uma nova Controller vazia, sem métodos.

public class MeuControladorController : Controller{
public void Mensagem(string mensagem)
{}
}


Logo podemos fazer que os nossos Controllers herdem do MeuControlador no lugar de Controller:

public class ClienteController : MeuControladorController{ }


Bem simples, agora todo o código que esta no MeuControllador é acessível a Controller Cliente.

public class ClienteController : MeuControladorController{
public ActionResult Index()
{
Mensagem("Você esta na tela de index.");
return View(new List<Cliente>());
}
}


Para finalizar

Este é apenas um exemplo dos usos da extensibilidade de Controller.
Toda vez que um dado código se repete mais de uma vez num Controller, é provável que seja um candidato a estar num Controller de base.

Lembrar sempre que a Controller tem apenas a funcionalidade de intermediar entre a Model e as Views.

Evite colocar nos Controllers código de regras de negocio ou de acesso a dados.



24. Views (shared, partial). Trabalhando com um Viewmodel.

Partial Views

São uma forma de reutilizar código Html. Toda vez que uma funcionalidade de View é comum a varias Views, podemos criar uma partial View e reutilizar-la.

Evitar duplicação de código.
Reutilizar e modularizar Views.


Partial Views

Há duas formas de utilizar uma partial View.

Partial View relativa ao Controller onde estamos usando a View.
Partial View Shared.
Com a primeira opção, a partial View será apenas para utilizar dentro do contexto daquele controller.
A segunda opção é para criar uma partial View de uso geral, que possa ser usado em todas as Views da aplicação.

Partial Views
O nome da Partial View por convenção começa com um _
O nome da Partial View por convenção termina com “Partial”
Uma Partial View pode usar um Model ou ViewModel


Para integrar uma Partial View numa View usamos o código:

<partial name=“_NomeDaViewPartial” model=“Model” />



25. O que é Razor? Exemplo de uso.

É um recurso de linguagem que nos permite adicionar lógica de programação numa página web.
Ou seja, nos permite utilizar código escrito em C# dentro de páginas HTML.

Razor é uma View Engine.

Para isto usamos uma marcação especial começando com @

@{
//Código C#
string mensagem = “Olá”;
}

Se usado dentro de um elemento HTML podemos usar diretamente o @

<p>@mensagem</p>

O código C# escrito dentro do bloco Razor será convertido a HTML uma vez que a aplicação é compilada.

Ou seja, não é possível executar código do lado do “cliente”.

Uma vez que solicitamos ao servidor uma página, e esta página contem código Razor, o servidor vai realizar
as operações necessárias para devolver uma página para o cliente onde o código Razor foi convertido em HTML.





26. Mapeamento Model->ViewModel


Mapeamento Model-ViewModel

Model - ViewModel

Um Model, ou modelo, se refere a uma camada do MVC, aquela camada que maneja os dados da aplicação.

Para manipular dados geralmente criamos classes. Essas classes chamamos também de Model.

Uma vez que manipulamos dados e utilizamos classes para isso, pode não ser uma boa opção passar dados que correspondem a uma camada Model especifica para as Views.
As vezes um Model de negócio pode conter informações que são sensíveis.

Então, como solucionar o problema e apenas apresentar na View os dados que o cliente pode ver?

Usamos ViewModels.

As ViewModels são classes simplificadas cuja única finalidade é apresentar dados nas Views ou enviar dados das Views ate o Controller.

Para poder trafegar a informação da camada de visualização ate a camada Model precisamos copiar um ViewModel a Model ou vice-versa.

Para isso usamos mapeamento.

Pode ser automático usando alguma ferramenta (automapper) Ou podemos fazer isso manualmente.

Vamos então, ver o uso Model-ViewModel e mapeamento manual...

Vamos ver isto funcionando...

O mapeamento manual implica igualar as propriedades de um objeto no outro:

Var clienteViewModel = new ClienteViewModel();
Var cliente = new ClienteModel();


Posso criar uma classe que faça a conversão:


Public class Cliente_ClienteViewModelMapper
{
public Cliente ClienteViewModel_ClienteMapper(ClienteViewModel clienteViewModel)
{
var cliente = new ClienteModel();
//mapping
cliente.Nome = clienteViewModel.Nome;
return cliente;
}
public ClienteViewModel Cliente_ClienteViewModelMapper(ClienteModel clienteModel)
{
var clienteViewModel = new ClienteViewModel;
//mapping
clienteViewModel.Nome = clienteModel.Nome;
return clienteViewModel;
}
}


27. Model Binding.

Model Binding no ASP.Net

Model binding se refere ao mapeamento entre uma requisição HTTP e uma Action num Controller.

Os parâmetros da Action são mapeados em relação aos parâmetros da requisição HTTP.

Estes parâmetros podem ser do tipo simples, integers, strings, ou complexos como classes com propriedades.

Um exemplo de mapeamento de binding é no caso da pagina de Details que já vimos antes.

No caso, o parâmetro é passado na request.

/Cliente/Details/1

Na action, o Controller vai fazer este mapeamento automático igualando o valor 1, ao parâmetros da Action int.

public ActionResult Details(int Id)


Mesmo neste caso o mapeamento é feito automaticamente por nome, no caso, Id. Se vemos a configuração de rotas do MVC encontramos o seguinte:

app.UseEndpoints(endpoints =>{
endpoints.MapControllerRoute(
name: "default",
pattern: "{controller=Home}/{action=Index}/{id?}");
});

O MVC vai então mapear qualquer valor da URL desde que respeitando esta formula.

Perceba que todo mapeamento feito automaticamente é feito graças ao nome dos parâmetros que deve ser o mesmo.

Assim, se quisermos passar tb o nome da pessoa no Details podemos fazer o seguinte:

public ActionResult Details(int Id, string Nome)

Mas é claro que ao tentar rodar o exemplo o valor de Nome será null. Para que funcione teríamos que mudar a URL:

/Cliente/Details/1?Nome=Jose

Notem que "Nome" na Url e o parâmetros da Action "Nome" são idênticos, é ali que a magia acontece.

Para poder fazer o Binding, ASP.Net vai buscar os parâmetros na request na seguinte ordem:

Forms
Routes
Query Strings

O model binding funciona nos dois sentidos, View->Controller e Controller->View.

Assim como podemos passar parâmetros simples, também podemos passar tipos complexos.

Se eu tenho uma classe "Cliente" com 3 campos, Id, Nome, Email.

Eu posso criar uma View usando este modelo e usando um Form, submeter esses dados para o Controller.

ASP.Net vai mapear cada elemento HTML a uma propriedade do modelo "Cliente".

Para isto vai usar as propriedades "name" do elemento HTML e mapear o elemento do mesmo nome na classe "Cliente".

<input type="text" name="Nome" />


O model binding também pode ser feito usando TagHelper


<input asp-for="Telefone" class="form-control" />


Ou usando Razor e Html helper

@Html.TextBoxFor(cliente => cliente.Nome);






28. Data annotations. Validação de dados.

29. Recapitulando
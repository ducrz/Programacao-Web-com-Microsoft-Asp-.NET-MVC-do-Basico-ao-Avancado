Seção 8: Usando acesso a dados numa aplicação Web


50. O que vamos aprender nesta seção?

Adicionando acesso a dados.


51. Introdução ao Entity Framework.


Ajuda a abstrair o acesso ao banco de dados.

É uma espécie de "camada" entre a aplicação e o banco de dados.


ORM Entity Framework.

Só para lembrar, o Entity Framework Core é um mapeador de banco de dados a objetos para .NET.

Suporta consulta LINQ, rastreamento de alterações, atualizações e migrações de esquema.

O EF Core trabalha com SQL Server, Banco de Dados SQL do Azure, SQLite, Azure Cosmos.


É o que chamados de ORM.


O Entity Framework Core é usado como uma forma de acessar um banco de dados e realizar operações.

O EF Core vai mapear o banco de dados e apresentar classes que representam os elementos do banco de dados.


Temos basicamente duas situações de mapeamento do banco:

- Banco de dados existente (legado).
- Banco de dados criado à partir da aplicação (code firts).

O EF Core usa classes para representar as entidades do banco de dados. Logo, é possível criar
as classes na aplicação e gerar o banco de dados a partir das classes. Isto é chamado de Code First.


CODE FIRST


Data Model (Classes) => Generated Database

Existing Databse => Generated Data Model (Classes).






52. Definição. Banco de dados. Modelo. Construção usando MSSQL.

Trabalhando com bancos de dados (basico)

Quando desenvolvemos com ferramentas da Microsoft nos temos a opção de usar diferentes bancos de dados do mercado.
O mais usado por desenvolvedores .Net no entanto é o SqlServer.

A ferramenta de administração de banco de dados neste caso é o SqlManagement Studio.

As duas ferramentas tem uma versão Express, ou seja, que é gratuita para uso.

Lembrando que as ferramentas Express tem sempre alguma limitação.

Porém para uso em aplicativos ate de mediano porte funcionam bem.

As duas ferramentas tem uma versão Express, ou seja, que é gratuita para uso.

Lembrando que as ferramentas Express tem sempre alguma limitação.

Porém para uso em aplicativos ate de mediano porte funcionam bem.


De forma simples podemos dizer que um banco de dados agrupa entidades que tem alguma relação lógica entre eles.

Banco de dados sistema de vendas:


Uma entidade é representada no banco de dados por uma tabela.

Entidades tem relações entre elas.

Uma nota de venda possui um ou mais produtos vendidos. Chamamos isso de relação de 1 para muitos.
Podemos tem três tipos de relações entre tabelas:

1 a 0
1 a N
N a N


Uma tabela tem campos ou atributos, cada campo representa uma informação.

A tabela cliente pode ter:

Nome
Sobrenome
CPF
RG
Etc...

Mas existe um campo que é importante numa tabela, é o campo chave.

O campo chave serve como identificador. Por isso os campos chave são chamados normalmente de ID.


Um campo chave é indispensável para identificar relações entre tabelas.

No exemplo, um Cliente pode ter uma relação com uma ou mais Vendas.

Para isto a tabela Vendas deve ter um campo que represente ao Cliente, que pode ser o ClienteId.


A criação do banco de dados, suas tabelas e suas relações, pode ser feita usando a ferramenta SqlManagement Express.


Podemos criar os objetos de forma manual ou criando o que se chamam scripts Sql


Microsoft SQL Server 2019 Express: https://www.microsoft.com/pt-br/sql-server/sql-server-downloads

Microsoft SQL Server 2017 Express: https://www.microsoft.com/pt-br/download/details.aspx?id=55994

SQL Server Management Studio: https://docs.microsoft.com/pt-br/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-ver15

Azure Banco de Dados SQL: https://portal.azure.com/#blade/HubsExtension/BrowseResourceBlade/resourceType/Microsoft.Sql%2Fservers%2Fdatabases


Criando DB no SQL Server Management Studio:

(localdb)\MSSQLLocalDB


CriandoDBTabelas.sql

InserindoESelect.sql


Criando diagramas: Database Diagrams.





53. ORM Entity Framework. Definição. Estrutura.


ORM Entity Framework
Só para lembrar, o Entity Framework Core é um mapeador de banco de dados a objetos para .NET.

Quer dizer que nos vamos ter uma representação do banco de dados em forma de classes.

Cada classe representando uma entidade (tabela).

Estas classes também possuem seus relacionamentos entre elas, podendo refletir relacionamentos reais do banco de dados ou não.

Para que o mapeamento seja feito na nossa aplicação adicionamos o que se chama de contexto de banco de dados.

DbContext

No .Net o contexto nada mais é do que uma classe que herda do DbContext do Entity Framework.

No DbContext nos podemos configurar os DbSets que correspondem as tabelas do banco de dados e os seus relacionamentos.
Com a vantagem que podemos configurar relacionamentos que não existem no banco real.

A partir de DbContext criado, é necessário configurar a string de conexão e alterar o Startup da nossa aplicação.

    "SqlConnection": "Server=(localdb)\\MSSQLLocalDB;Initial Catalog=LocadoraDB;Integrated Security=True;"


(localdb)\MSSQLLocalDB



54. Code first. Construindo banco de dados usando como modelo a estrutura de classes.


Code First

Se o banco de dados ainda não existe, nós podemos usar a técnica do Code First.

Ou seja, código primeiro. Quer dizer que nos vamos escrever as nossas classes, que futuramente serão nossas entidades de banco de dados, e depois utilizar uma técnica
para poder criar o banco de dados a partir das nossas classes.

Esta técnica é Migrations.

Migrations

Para poder fazer o update da estrutura do banco de dados, nos utilizamos as Migrations. Instalar o pacote “tools” do entity framework.
Migrations é uma funcionalidade executada por linha de comando que permite manipular a estrutura do banco de dados usando como base o modelo de classes da
nossa aplicação.
Toda alteração nas nossas classes vai ser propagado ao banco de dados usando Migrations.
Também facilita e muito o versionamento do banco de dados e o rollback. Ou seja, a eventual volta atrás à versão antiga do banco de dados.

Podemos aplicar Migrations desde a linha de comando ou usando o Package Manager Console desde o Visual Studio.

[Command Line]
dotnet ef migrations add <name of migration>

[Package Manager console]
add-migration <name of migration>


Migrations, operações possíveis

Add-migration, permite adicionar uma evolução ao banco de dados. Cada Migration possui um método Up e outro Down.

Dessa maneira todas as alterações que adicionem algo ao banco de dados são colocadas no método Up, todas as alterações que deletem uma tabela, um campo, etc,
são colocadas no método Down.

[Command Line]
dotnet ef migrations add <name of migration>

[Package Manager console]
add-migration <name of migration>


Update-database. Uma vez que adicionei a migration, já posso atualizar o banco de dados. Para isto utilizo o update-database.
Uma migration ou um grupo de migrations serão executadas e o banco de dados será atualizado.

[Command line]
dotnet ef database update

[Package Manager Console]
update-database


Package manager console.

View > Other Windows >  Package Manager Console.


PM> add-migration bd-criacao


add-migration bd-criacao -Project LocadoraDeCarros


Adicionar: Microsoft.EntityFrameworkCore.Tools

Importante: Checar o Default Project no Package Manager Console.

Folder: Migrations.



Executar: update-database

add-migrations adiciona-telefones




55. Linq to entities.

Permite realizar consultas.


Linq to Entities
Linq nos permite realizar consultas nos mais variados origens de dados. Podemos realizar uma consulta Linq num banco de dados.
É justamente isto que se chama de Linq to Entities.
A consulta é criada em Linq e passada ao Entity Framework. Do EF vai passar pela camada ADO.Net e é esta camada que vai “traduzir” a consulta numa linguagem que o
banco de dados de destino entenda, ou seja, SQL.


Quando construímos consultas Linq to Entities, a consulta nem sempre é executada imediatamente no banco de dados.

Isto é porque a consulta somente é enviada e executada no banco de dados quando houver um certo gatilho.

var listaClientes = _contexto.Cliente.Where(cliente => cliente.Idade > 15);
listaClientes = listaClientes.Where(cliente => cliente.Cidade == “São Paulo”);

Uma consulta esta sendo construída, mas ainda não foi executada no banco de dados.


O que chamo de gatilho é na verdade uma chamada a um método de extensão que fara finalmente a execução no banco de dados.

Um desses métodos é o ToList()

var listaClientes = _contexto.Cliente.Where(cliente => cliente.Idade > 15).ToList();


Existem outros métodos que também executam a consulta no banco de dados:
Max(), Count(), FirstOrDefault(), etc


O Linq de forma geral, nos permite também realizar consultas sobre os itens relacionados à entidade principal que estamos consultando.

Por exemplo, podemos ter uma tabela Estudantes e outra Cursos.

Com certeza existe uma relação ali, onde um Estudante pode estar matriculado em vários cursos.

Em Linq nos podemos criar uma consulta onde vamos buscar o Estudante e trazer ao mesmo tempo todos os cursos relacionados.

Var listaEstudanteCursos = _contexto.Estudante.Where(estudante =>
estudante.Curso.Ano == “2020”).ToList();

“Curso” é outra entidade, veja que eu posso “navegar” pelas propriedades e fazer filtros.



As propriedades de navegação, como no caso do exemplo “Curso”, são carregadas junto com a consulta e para isso o Entity Framework pode trabalhar em dois modos diferentes.

Eager loading
Lazy loading

Eager loading

No Eager loading as entidades relacionadas são carregadas ao mesmo tempo que a consulta principal, desta forma o Entity Framework só fara uma viagem ao banco de
dados.
Podemos carregar as entidades relacionadas com Eager loading usando o método de extensão Include.

Var listaEstudanteCursos = _contexto.Estudante.Include(“Curso”).Where(estudante =>
estudante.Curso.Ano == “2020”).ToList();

Note que se eu estiver usando Eager loading e não especifico o Include, a instrução a seguir dará erro de null.


Lazy loading

No Lazy loading as entidades relacionadas não são carregadas imediatamente, o carregamento é adiado ate o momento que os dados da entidade relacionada forem necessários. Desta forma o
Entity Framework fara uma viagem para carregar os dados da tabela Estudante e logo mais tarde, quando for necessário, fara outra consulta no banco de dados para recuperar os cursos.

Var listaEstudanteCursos = _contexto.Estudante.Where(Id == 1).ToList();
Var cursos2020 = listaEstudanteCursos.Where(estudante => estudante.Curso.Ano == “2020”);

A desvantagem do Lazy loading é que sem querer você pode estar fazendo consultas no banco de dados que não eram necessárias.

A vantagem é que se você esquece de fazer o Include, como no caso do Eager, você não tem erro de null ao tentar acessar a propriedade de navegação.


Não existe uma solução ideal. Alguns programadores preferem usar Eager loading por conta de ter maior controle sobre o que é executado ou não no banco de dados.
Outros preferem já ter tudo “pre-carregado” por se acaso for necessário durante o decorrer do programa o acesso a esses dados sem ter que alterar a consulta.



56. Recapitulando